#
#
### Author: wei.loonx.teh@intel.com ####
##############################################################################################################################################
### Description: This script is meant for LPE automation test's flow governing which accepts and parses list of parameters inputted by 
###              user and pass it to the test execution script. After the test execution is done, it will then return final verdict of the
###              test based on test output that generated by the execution script. 
##############################################################################################################################################
###
#
#
#!/usr/bin/python


import os
import re
import sys
import getopt
import wave
import glob
import contextlib
import time
import traceback
import subprocess
import datetime
from datetime import *
from GenericCommand import *



def get_date():

    "return date in <year.month.day> format"
    today = date.today()
    day = str(today.day)
    month = str(today.month)
    year = str(today.year)

    if(len(day)==1):
        day = "0" + day 
    if(len(month)==1):
        month = "0" + month

    currentDate = year +"." + month + "." + day
    return currentDate
    
    
def get_current_time():

   "return time in <hour.minute.second> format"
   currentTime = datetime.time(datetime.now()) 
   time_Hour = currentTime.hour
   time_Minute = currentTime.minute
   time_Second = currentTime.second
   Time_now = str(time_Hour) + "." + str(time_Minute) + "." + str(time_Second)
   return Time_now



def logging(logfile,logmsg):

    "A simple logging function, usage: function(logfile's location,log message)"
    logger = open(str(logfile),'a')
    logger.write("\n" + str(logmsg))
    logger.close()

    
def execute(comm=''):
    resp = ""
    if comm == '':
        print 'execute() Error: Argument is empty!'
        return False
    else:
        try:
            for stuff in os.popen(comm):
                resp += stuff
            return resp
        except:
            print 'execute() Error: Unable to execute command.'
            return False



def remote_script_filesend(script_name,ori_loc,target_loc,obj,sutip,thmip):

    "Sending a file to a remote machine and check for its existence"
    myscript = """
import os
import time
import sys
from GenericCommand import *

thm = GenericCommand()
thm.login(\'""" + sutip + """\')
thm.timefiletransfer(\'""" + ori_loc + """\',\'""" + target_loc + """\')
filetrace = thm.timefiletrace(\'""" + target_loc + """\')"""
    obj = GenericCommand()
    obj.login(thmip)
    obj.execute("rm -rf /" + script_name + "*")
    obj.timefilescript(myscript,r"/",script_name,".py")
    obj.execute("python /" + script_name + ".py")
    obj.login(sutip)
    check = obj.timefiletrace(target_loc)
    print check
    if "target exists" in check:
          print target_loc + " successfully transmitted"
    else:
          print "failed to transmit " + target_loc
          sys.exit(1)



def remote_script_execute(content,script_name,obj,sutip):

    "Send a script to a remote machine and execute it"
    obj = GenericCommand()
    obj.login(sutip)
    obj.execute("rm -rf /" + script_name + "*")
    obj.timefilescript(content,r"/",script_name,".py")
    output = obj.execute("python /" + script_name + ".py")
    return output



def xfinder(filepath,filepattern,maxdepth):
 
    "File searching function"
    output = subprocess.check_output("find " + filepath + " -maxdepth " + str(maxdepth) + " -name " + filepattern,shell=True)
    output = output.strip()
    output = output.split("\n")
    if len(output) > 1:
         print "More than 1 file matched with specified file pattern " + filepattern + " and " + str(maxdepth) + " directory depth"
         logging(str(LPElog),"More than 1 file matched to specified file pattern" + filepattern + " and " + str(maxdepth) + "  directory depth")
         print output
         logging(str(LPElog),str(output))
         exit(1)
       
    elif len(output) == 1:
         return output[0]
    else:
         return ''


###########################################LAUNCHER FUNCTION START FROM HERE#############################################################

def result_parser(output):
    
    "Perform auto ear generated log result parsing"
    global dict
    global result_output
    dict = {}
    chl_list = []
    rate_list = []
    result_output = []
    date = ""
    verdict = True

    date_regex = re.compile(r'\d+-\d+-\d+')
    for word in output:
         date_match = date_regex.search(word)
         if date_match:
             date = str(date_match.group(0))
             break
         
    if date:
	 print "***Extracting result from AUTOEAR server***"
         if debug:
             print "Date pattern extracted for regex filtering :" + date
         logging(LPElog,"Date pattern extracted for regex filtering :" + date)
    else:
         if debug:
             print "Date pattern required for regex filtering not found"
         logging(LPElog,"Date pattern required for regex filtering not found")
         sys.exit(1)

 
    for line in output:
         if "Audio content size" in line and date not in line:
                match_chl = re.search(r'channel \d',line)
                if match_chl:
                    chl_list.append(match_chl.group(0))
         
         elif "Total Similarity" in line:
                match_rate = re.search(r'\d+.\d+%',line)
                if match_rate:
                    rate_list.append(match_rate.group(0))
   
    print "Retrieving data....." 
    if not chl_list or not rate_list:
          print "***Failed to retrieve comparison result, the Audio Comparison App might has crashed***"
	  raise Exception("Exception caught,AutoEar App crashed")

          
    else:
          print chl_list
          print rate_list
    time.sleep(5) 

    threshold_dict = {"0":threshold_ch0,"1":threshold_ch1,"2":threshold_ch2,"3":threshold_ch3,"4":threshold_ch4,"5":threshold_ch5,"6":threshold_ch6,"7":threshold_ch7}               
    #Dictionary comprehension from Ang to map channel number to its respective similarity rate
    dict = { j:rate_list[i] for i,j in enumerate(chl_list)}
    for i,j in  dict.items():
        if "--threshold_ch" + i.split(" ")[-1] in opt_list:
                 threshold = threshold_dict[i.split(" ")[-1]]
        else:
                 threshold = threshold_main
        if float(j[:-1]) < float(threshold):
               #print i + " similarity :" +  j  + " ,lower than " + threshold + "%, Verdict: Failed"
               result_output.append(i + " similarity :" +  j  + " ,lower than " + threshold + "%, Verdict: Failed")
               logging(LPElog,i + " similarity :" +  j  + " ,lower than " + threshold + "%, Verdict: Failed")
               verdict = False
        else:
               #print i +  " similarity :" + j + " ,greater than " + threshold + "%, Verdict: Passed"
               result_output.append(i +  " similarity :" + j + " ,greater than " + threshold + "%, Verdict: Passed")
               logging(LPElog,i +  " similarity :" + j + " ,greater than " + threshold + "%, Verdict: Passed")
    return verdict




def audio_compare(obj,winip,gold,target,port,conf,mode):

   
    "Perform audio files comparison with Auto Ear" 
    global verdict
    verdict = False
    obj.login(winip)
    try:
       print "gold file = " + gold
       print "output file = " + target
       obj.execute("mkdir C:\\LPE_Compare_Log")
       obj.execute("mkdir C:\\LPE_output")
       output = obj.execute("C:\WinAutoEar\AudioCompare.exe compare " + str(threshold) + " " + gold + " " + target + " C:\LPE_Compare_Log\compare.log")
       output = output.split("\n")
       date_stamp = get_date() + "_" + get_current_time()
       with open("C:\\LPE_Compare_Log\\stdout.txt","a") as file:
              for line in output:
                  if debug:
                      print line
                  obj.execute("echo '" + line + "' >> C:\\LPE_Compare_Log\\stdout.txt")
                  if "Test PASSED" in line:
                         verdict = True
                         obj.execute("RENAME C:\\LPE_Compare_Log\\stdout.txt stdout_" + date_stamp + "_" + port + "-" + conf + "_" + mode + "_PASS_" + ".log") 
                         break
       if verdict == False:           
             obj.execute("RENAME C:\\LPE_Compare_Log\\stdout.txt stdout_" + date_stamp + "_" + port + "-" + conf + "_" + mode + "_FAIL_" + ".log") 

       log_output = obj.execute("type C:\\LPE_Compare_Log\\compare.log")
       if verdict == True:
             obj.execute("RENAME C:\\LPE_Compare_Log\\compare.log compare_" + date_stamp + "_" + port + "-" + conf + "_" + mode + "_PASS_" + ".log") 
       else:
              
             obj.execute("RENAME C:\\LPE_Compare_Log\\compare.log compare_" + date_stamp + "_" + port + "-" + conf + "_" + mode + "_FAIL_" + ".log") 

       print "Original Output File: " + target
       target_file = target.split("\\")[-1]
       target_file = target_file.split(".")[0]
       obj.execute("MOVE " + target + " C:\\LPE_output\\" + target_file + "_" + date_stamp + "_" + port + "-" + conf  + "_" + mode + ".wav")
       print "Renamed Output File: " + "C:\\LPE_output\\" + target_file + "_" + date_stamp + "_" + port + "-" + conf + "_" + mode + ".wav"
       obj.execute("DEL C:\\temp\*.fft")
       obj.execute("DEL C:\\gold\*.fft")
    except Exception, error:
       type_, value_, traceback_ = sys.exc_info()
       print str(error)
       logging(LPElog,str(error))
       print traceback.format_tb(traceback_)
       logging(LPElog,traceback.format_tb(traceback_))
       obj.execute("taskkill /F /im AudioCompare.exe")
       autoear_crash_check = obj.execute("tasklist")
       autoear_kill = True
       for line in autoear_crash_check:
              if "AudioCompare.exe" in line:
                       autoear_kill = False
       obj.execute("taskkill /F /im notepad.exe")
       if autoear_kill:
               print "Auto Ear Apps has been resetted"
       else:
               print "Failed to reset Auto Ear Apps"
       print "exception caught"
       sys.exit(1)




def audio_compare_similarity(obj,winip,gold,target,port,conf,mode):

   
    "Perform audio files comparison with Auto Ear(ignore glitches but similiarity)" 
    global verdict
    verdict = False
    obj.login(winip)
    try:
       print "gold file = " + gold
       print "output file = " + target
       obj.execute("mkdir C:\\LPE_Compare_Log")
       obj.execute("mkdir C:\\LPE_output")
       threshold = 90
       output = obj.execute("C:\WinAutoEar\AudioCompare.exe compare " + str(threshold) + " " + gold + " " + target + " C:\LPE_Compare_Log\compare.log")
       output = output.split("\n")
       date_stamp = get_date() + "_" + get_current_time()
       verdict = result_parser(output)
       with open("C:\\LPE_Compare_Log\\stdout.txt","a") as file:
              for line in output:
                  if debug:
                     print line
                  obj.execute("echo '" + line + "' >> C:\\LPE_Compare_Log\\stdout.txt")
              for result in result_output:
                  obj.execute("echo '" + result + "' >> C:\\LPE_Compare_Log\\stdout.txt")
       if verdict == True:
              obj.execute("RENAME C:\\LPE_Compare_Log\\stdout.txt stdout_" + date_stamp + "_" + port + "-" + conf  + "_" + mode + "_PASS_" + ".log") 
       if verdict == False:           
             obj.execute("RENAME C:\\LPE_Compare_Log\\stdout.txt stdout_" + date_stamp + "_" + port + "-" + conf + "_" + mode + "_FAIL_" + ".log") 

       log_output = obj.execute("type C:\\LPE_Compare_Log\\compare.log")
       if verdict == True:
             obj.execute("RENAME C:\\LPE_Compare_Log\\compare.log compare_" + date_stamp + "_" + port + "-" + conf + "_" + mode + "_PASS_" + ".log") 
       else:
              
             obj.execute("RENAME C:\\LPE_Compare_Log\\compare.log compare_" + date_stamp + "_" + port + "-" + conf + "_" + mode + "_FAIL_" + ".log") 

       print "Original Output File: " + target
       target_file = target.split("\\")[-1]
       target_file = target_file.split(".")[0]
       obj.execute("MOVE " + target + " C:\\LPE_output\\" + target_file + "_" + date_stamp + "_" + port + "-" + conf + "_" + mode + ".wav")
       print "Renamed Output File: " + "C:\\LPE_output\\" + target_file + "_" + date_stamp + "_" + port + "-" + conf + "_" + mode +".wav"
       obj.execute("DEL C:\\temp\*.fft")
       obj.execute("DEL C:\\gold\*.fft")
    except Exception, error:
       type_, value_, traceback_ = sys.exc_info()
       print str(error)
       logging(LPElog,str(error))
       print traceback.format_tb(traceback_)
       logging(LPElog,traceback.format_tb(traceback_))
       obj.execute("taskkill /F /im AudioCompare.exe")
       autoear_crash_check = obj.execute("tasklist")
       autoear_kill = True
       for line in autoear_crash_check:
              if "AudioCompare.exe" in line:
                       autoear_kill = False
       obj.execute("taskkill /F /im notepad.exe")
       if autoear_kill:
               print "Auto Ear Apps has been resetted"
       else:
               print "Failed to reset Auto Ear Apps"
       print "exception caught"
       sys.exit(1)




if __name__ == '__main__':

    LPElog = "/root/LPE.log"
    os.system("rm -rf " + LPElog)

    autoduration = True
    timeout = 10
    menu = False
    mute = False
    SSP0 = False
    SSP1 = False
    SSP2 = False
    SSP0_verdict = False
    SSP1_verdict = False
    SSP2_verdict = False
    glitch_bypass = False
    debug = False
    threshold_ch0 = None
    threshold_ch1 = None
    threshold_ch2 = None
    threshold_ch3 = None
    threshold_ch4 = None
    threshold_ch5 = None
    threshold_ch6 = None
    threshold_ch7 = None
    
    
    codec_list = [['SSP0',SSP0,SSP0_verdict],['SSP1',SSP1,SSP1_verdict],['SSP2',SSP2,SSP2_verdict]] 
    
    

    try:
    	   opts, args = getopt.getopt(sys.argv[1:], '', ['thmip=','sutip=','sutip2=','winip=','song=','rectime=','output=','mode=','gold=','driver=','SSP0=','SSP1=','SSP2=','threshold=','threshold_ch0=','threshold_ch1=','threshold_ch2=','threshold_ch3=','threshold_ch4=','threshold_ch5=','threshold_ch6=','threshold_ch7=','mute','glitch_bypass','debug','help']) # Henri add driver
    	   for opt, arg in opts:
       	       if opt == '--sutip':
                   sutip = str(arg)
       	       elif opt == '--sutip2':
                   sutip2 = str(arg)
	       elif opt == '--winip':
            	   winip = str(arg)
	       elif opt == '--thmip':
            	   thmip = str(arg)
               elif opt == '--song':
                   song = str(arg)
               elif opt == '--threshold':
                   threshold_main = str(arg)
               elif opt == '--threshold_ch0':
                   threshold_ch0 = str(arg)
                   print "Channel 0's threshold set as: " + str(threshold_ch0)
               elif opt == '--threshold_ch1':
                   threshold_ch1 = str(arg)
                   print "Channel 1's threshold set as: " + str(arg)
               elif opt == '--threshold_ch2':
                   threshold_ch2 = str(arg)
                   print "Channel 2's threshold set as: " + str(arg)
               elif opt == '--threshold_ch3':
                   threshold_ch3 = str(arg)
                   print "Channel 3's threshold set as: " + str(arg)
               elif opt == '--threshold_ch4':
                   threshold_ch4 = str(arg)
                   print "Channel 4's threshold set as: " + str(arg)
               elif opt == '--threshold_ch5':
                   threshold_ch5 = str(arg)
                   print "Channel 5's threshold set as: " + str(arg)
               elif opt == '--threshold_ch6':
                   threshold_ch6 = str(arg)
                   print "Channel 6's threshold set as: " + str(arg)
               elif opt == '--threshold_ch7':
                   threshold_ch7 = str(arg)
                   print "Channel 7's threshold set as: " + str(arg)
               elif opt == '--rectime':
                   rec_duration = str(arg)
                   autoduration = False
               elif opt == '--driver': # Henri add
                   driver = str(arg)   # Henri add 
               elif opt == '--SSP0':
                   codec_list[0].append(str(arg))
                   codec_list[0][1] = True
                   if str(arg) != "tdm" and str(arg) != "i2s":
                           print codec_list[0][0] + " only accept [tdm|i2s] as input, exp: --SSP0 tdm or --SSP0 i2s"
                           logging(LPElog,codec_list[0][0] + " only accept [tdm|i2s] as input, exp: --SSP0 tdm or --SSP0 i2s")
                           sys.exit(1)
               elif opt == '--SSP1':
                   codec_list[1].append(str(arg))
                   codec_list[1][1] = True
                   if str(arg) != "tdm" and str(arg) != "i2s":
                           print codec_list[1][0] + " only accept [tdm|i2s] as input, exp: --SSP0 tdm or --SSP0 i2s"
                           logging(LPElog,codec_list[1][0] + " only accept [tdm|i2s] as input, exp: --SSP0 tdm or --SSP0 i2s")
                           sys.exit(1)
               elif opt == '--SSP2':
                   codec_list[2].append(str(arg))
                   codec_list[2][1] = True
                   if str(arg) != "tdm" and str(arg) != "i2s":
                           print codec_list[2][0] + " only accept [tdm|i2s] as input, exp: --SSP0 tdm or --SSP0 i2s"
                           logging(LPElog,codec_list[2][0] + " only accept [tdm|i2s] as input, exp: --SSP0 tdm or --SSP0 i2s")
                           sys.exit(1)
               elif opt == '--output':
                   output = str(arg)
               elif opt == '--gold':
                   gold = str(arg)
               elif opt == '--mode':
                   mode = str(arg).lower()
               elif opt == '--help':
                   menu = True
               elif opt == '--mute':
                   mute = True
               elif opt == '--glitch_bypass':
                   glitch_bypass = True
               elif opt == '--debug':
		   debug = True

    except StandardError , e:
           print e
           print "try --help to get some clues"
 
    if menu:
       print """python <script name>  <args>
  list of Arguments
  =======================================
   --sutip         ==> to set SUT ip                             (mandatory)
 
   --sutip2        ==> to set 2nd SUT ip                         (mandatory) ###Only if slave mode is on### 
                                  
   --winip         ==> to set windows ip                         (mandatory)

   --thmip         ==> to set THM ip                             (mandatory)
                                  
   --song          ==> to specify Original song for playback     (mandatory)

   --gold          ==> to specify gold song name and directory   (mandatory)

   --mode          ==> to specify running in master or slave mode(mandatory)

   --driver        ==> to specify driver as IA or IAFW           (mandatory)

   --threshold     ==> to specify similarity threshold           (mandatory)
 
   --threshold_ch0 ==> to specify channel 0 similarity threshold (optional) 

   --threshold_ch1 ==> to specify channel 1 similarity threshold (optional)
    
   --threshold_ch2 ==> to specify channel 2 similarity threshold (optional)

   --threshold_ch3 ==> to specify channel 3 similarity threshold (optional)

   --threshold_ch4 ==> to specify channel 4 similarity threshold (optional)

   --threshold_ch5 ==> to specify channel 5 similarity threshold (optional)

   --threshold_ch6 ==> to specify channel 6 similarity threshold (optional)

   --threshold_ch7 ==> to specify channel 7 similarity threshold (optional)
   
   --SSP0          ==> to trigger test running on SSP0 port      (optional) ###atleast one SSP port is required###

   --SSP1          ==> to trigger test running on SSP1 port      (optional) ###atleast one SSP port is required###
    
   --SSP2          ==> to trigger test running on SSP2 port      (optional) ###atleast one SSP port is required###
                                  
   --rectime       ==> to set record duration                    (optional) ### no default value ###
             
   ***if rectime not specified, auto song length estimation will be implemented***
                                  
   --output        ==> to specify output file name and directory (optional) ### default: /output.wav ###
   
   --mute          ==> to mute playback                          (optional) ### no arg value ###

   --glitch_bypass ==> to specify test running in glitch bypassed verdict mode

   --help          ==> to view list of arguments                 (optional) ### no arg value ###"""


       sys.exit(0) 







    #check if atleast one port is assign with codec mode
    checker = False
    for i in codec_list:
        if i[1] == True:
           print i[0] + ": " + str(i[1])
           logging(LPElog,i[0] + ": " + str(i[1]))          
           checker = True
    if checker == False:
       print "Please trigger atleast one port for test execution."
       sys.exit(1)

    #check if all mandatory aruguments has been defined
    opt_list = []
    for i in opts:
         opt_list.append(i[0])
    
    arg_log = ""
    arg_list = ["--sutip","--thmip","--winip","--song","--gold","--mode"]
    for i in arg_list:
             if i not in opt_list:
                 arg_log = arg_log + "[Error] Argument for " + i + " is required\n"
    if arg_log != "":
          print arg_log
          sys.exit(1)
        
 
    
    worker1 = GenericCommand()
    
    print "SUT ip = " + sutip

    #Copy over ORI files from THM to SUT
    worker1.login(sutip)
    print "RETRIEVING Kernel Command Line from SUT: " + worker1.execute("cat /proc/cmdline")
    pre_filetrace = worker1.timefiletrace(song)
    print pre_filetrace
    if "target exists" not in pre_filetrace:
              
        worker1.timefiletransfer(song,song)
        filetrace = worker1.timefiletrace(song)
        print filetrace
        if "target exists" not in filetrace:
            print "\n" + song + " file not found"
            logging(LPElog,"\n" + song + " file not found") 
            sys.exit(1)
        else:
            print song + "successfully transferred"
            logging(LPElog,song + "successfully transferred")

    
    content = """
import os
import subprocess

def xfinder(filepath,filepattern,maxdepth):
 
    output = subprocess.check_output(\"find \" + filepath + \" -maxdepth \" + str(maxdepth) + \" -name \" + filepattern,shell=True)
    output = output.strip()
    output = output.split('\n')
    if len(output) > 1:
         print "More than 1 file matched with specified file pattern \" + filepattern + \" and \" + str(maxdepth) + \" directory depth\"
         print output
         exit(1)
       
    elif len(output) == 1:
         return output[0]
    else:
         return ''    
#Check GenericCommand readiness

if os.path.isfile(\"/usr/lib/python2.7/site-packages/GenericCommand.py\"):
    from GenericCommand import *
    print 'GC imported'
else:
    temp = xfinder(\"/usr/local/gv\",\"*Command.py\",20)
    if temp != '':
          os.system(\"cp -r \" + temp + \" /usr/lib/python2.7/site-packages\")
          from GenericCommand import *
	  print 'GC imported'
    else:
	  print 'Error occured, GC not imported'
          sys.exit(1) """

    """
    return_output = remote_script_execute(content,"check_GC","sut",sutip)
    return_output = return_output.strip()
    
    filetrace = worker1.timefiletrace("/check_GC.py")
    if "target exists" not in filetrace:
        print "\n/check_GC.py file not found"
        logging(LPElog,"\n/check_GC.py file not found")
        sys.exit(1)
    else:
        print  "check_GC.py successfully transferred"
        logging(LPElog,"check_GC.py successfully transferred")

    print "Retrieving return message from GC checking script... "
    print "Message: " + return_output 
    if return_output == '' or return_output != 'GC imported':
	print "Failed to import Generic Command"
	logging(LPElog,"\nFailed to import Generic Command")
	sys.exit(1)
    """

    #Henri Add: Checking of Image of the day is released. Else fail test
    # After running BzImgUpdate.py, latest_img will be updated with the latest image name, assuming that there is image on the current day
    # Else, it will remain will the previous updated image. Hence, if current date & date recorded contradicts, hence test fails.
    last_img_update = worker1.execute("cat /root/Image/latest_img")
    current_img = "bzImage_LPE_" + get_date().replace(".", "-")
    
    if debug:
        print "Last image name" = last_img_update
        print "Current image" = current_img
    
    if last_img_update == current_img
        test_verdict = True
    else
        test_verdict = False
        
    if test_verdict:
        #Argument list compilation and passing from main script to execution script
        param0 = ""
        param1 = ""
        param2 = ""
        for i in codec_list:
              if i[1] == True:
                  if i[0] == "SSP0":
                      param0 = " -ssp0 " + i[-1]
                  elif i[0] == "SSP1":
                      param1 = " -ssp1 " + i[-1]
                  elif i[0] == "SSP2":
                      param2 = " -ssp2 " + i[-1]
                  else:
                      pass
        param_list = [param0,param1,param2]
        final_param = ""
        for i in param_list:
             if i != "":
                 final_param = final_param + i
        print "PARAMETERS combined from all codecs: " + final_param
        if "slave" in mode:
              final_param = " -j " + sutip2 + final_param
        print "ARGUMENTS LIST for execution: " + "python //LPE_automation.py -i " + sutip + " -d " + driver + " " + final_param + " -f " + song + " -m " + mode  

     
        worker1.login(thmip)
        #Launch execution script with pre-compiled argument list
        execution = worker1.execute("python //LPE_automation.py -i " + sutip + " -d " + driver + " " + final_param + " -f " + song + " -m " + mode)
        print execution
        logging(str(LPElog),str(execution))
        time.sleep(5)


        try:
            worker1.login(winip)
            filepath = "C:\\temp\\"
            #Lambda function for file searching on windows host
            find = lambda x:worker1.execute("dir /B " + filepath + x + "*").strip()
            for i in codec_list:
                   if i[1] == True:
                        temp = find(i[0])
                        if "\n" in temp:
                            print "More than one file detected for " + i[0]
                            logging(str(LPElog),"More than one file detected for " + i[0])
                            worker1.execute("DEL C:\\temp\*.fft")
                    worker1.execute("DEL C:\\temp\*.wav")
                            print temp
                            for i in temp:
                    print "Deleting " + i
                            sys.exit(1)
                        if temp == "":
                            print i[0] + " audio file not detected!!!"
                            logging(str(LPElog),i[0] + " audio file not detected!!!")
                            sys.exit(1)
                        temp = filepath + temp
                        print "File detected: " + temp
                        if glitch_bypass:
                             print "\n***Running in GLITCH bypassing mode***"
                             audio_compare_similarity(worker1,winip,gold,temp,i[0],i[-1],mode)
                        else:
                             print "\n***Running in non GLITCH bypasssing mode***"
                             audio_compare(worker1,winip,gold,temp,i[0],i[-1],mode)
                        if verdict:
                             i[2] = True


        except Exception, error:
            type_, value_, traceback_ = sys.exc_info()
        print str(error)
        print traceback.format_tb(traceback_)
        sys.exit(1)
        
        final_verdict = True

    else:
        print "No new image (" + current_img + ") available."
        final_verdict = False
    

    #FINAL VERDICT

    print "\n\n\nRESULTS"
    print "================="
    #final_verdict = True
    for i in codec_list:
        print i[0] + ": " + str(i[1])
        if i[1] == True:
            result = lambda x:'PASS' if x == True else 'FAIL'
            print "Verdict for " + i[0] + ": " + result(i[2])
            logging(LPElog,"Verdict for " + i[0] + ": " + result(i[2]))
            if not i[2]:
                final_verdict = False
    print "=================="
    if final_verdict:
        if glitch_bypass:
            for i in result_output:
                 print i  
        print "Final Verdict: PASS"
        sys.exit(0)
    else:
        if glitch_bypass:
            for i in result_output:
                 print i  
        print "Final Verdict: FAIL"
        sys.exit(1)

  
