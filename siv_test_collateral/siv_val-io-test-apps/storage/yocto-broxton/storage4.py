# if you have alias of cp and rm in your .bashrc file, please remove it prior running this script.
# copy partitions.sh to /root folder in Fedora
# copy partitions.sh to /data folder in Android







#
#
# storage.py -i [number_of_iteration] -t [TestCaseID] -p [number_of_partition] -f [format_type] -d [device] -b [mount_base] -s [OS] -o [Operation] -e [Storage_type] -q [Test Machine IP]
#
# number_of_iteration = number of copy from boot device to first storage partition, this is for stress test purpose
# TestCaseID = testcaseid from TCS
# number_of_partition = number of storage partition that will be generated by this script
# format_type = [ext2, ext3, ext4, vFAT, FAT32]
# device = Example: /dev/sdb, /dev/sdc
# mount_base = target mount directory. Example, if /media/SATA is selected, partition 1 will be /media/SATA1, partition 2 will be /media/SATA2
#              partition 3 will be /media/SATA3, partition 4 will be /media/SATA4, partition 5 will be /media/SATA5 
# OS = [fedora16, android]
# Operation = [partition, unmount, format, mount, create_file, create_multiple_file, copy_across, copy_compare_stress]
# Storage_type = [USB, SATA, SD], this will determine on the location of the logfiles.
# 
# 
#

import sys
import os
import re
import time
#import multiprocessing

from datetime import date, datetime

import subprocess
#import GenericCommand
import common
import getopt



# Meego_Host_IP = "172.30.66.81"
# Meego_Host_IP = "172.30.68.81"
#Meego_Host_IP = "172.30.66.82"
# storage_base = "/media/storage"
# Meego_storage_file_size = "df | grep /media/storage | awk '{print $2}'"
#blockcount = "10"
#testVerdict = True

#
# This function will mount all the partition to the system. Mount point will be based on the storage_base.
# Example, storage_base is /media/SATA, mount point will be /media/SATA1, /media/SATA2, /media/SATA3, 
#

def execute(cmd):

	output = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE).communicate()
	if not output[1]:
		return output[0]
	else:
		return output[1]
	
def storage_mount(partition, device, storage_base, testVerdict):
    if (OS == "fedora16"):
    	cmd_list_mount = "df"
    elif (OS == "android"):
	cmd_list_mount = "adb shell df"
    response = execute(cmd_list_mount)

    for x in range (0, int(partition)):
        if (x <=2):             # primary partition only
            device_number = x + 1
        else:                   # skip extended partition 
            device_number = x + 2
        if (storage == "SD"):
            real_device = device + "p" + str(device_number) #create correct device number. This will skip the extended partition (if partition is more than 4 partitions, the 4th partition is extended partition
        else:    
            real_device = device + str(device_number) #create correct device number. This will skip the extended partition (if partition is more than 4 partitions, the 4th partition is extended partition
        storage_number = x + 1
	storage_mount_point = storage_base + str(storage_number) #create mount pount with incremental number.
	if re.search(storage_mount_point, response):  # check if mount already existed
	    print storage_mount_point + " already mounted" 
	    cmd_logging = "echo " + storage_mount_point + " already mounted >> " +  testlog
	    #print cmd_logging
	    execute (cmd_logging)
        else: #mount not exist
            print storage_mount_point + " not mounted"
	    cmd_logging = "echo " + storage_mount_point + " not mounted >> " + testlog 
	    execute(cmd_logging)
	    print "mounting " + storage_mount_point + " ...."
	    cmd_logging =  "echo mounting " + storage_mount_point + " .... >> " + testlog 
	    execute(cmd_logging)
	    if (OS == "fedora16"):
	    	cmd_mkdir = "mkdir " + storage_mount_point
	    elif (OS == "android"):
	    	cmd_mkdir = "adb shell mkdir " + storage_mount_point
	    print cmd_mkdir	
	    execute(cmd_mkdir)
	    if (OS == "fedora16"):
	    	cmd_mount = "mount " + real_device + " " + storage_mount_point
	    if (OS == "android"):
	    	cmd_mount = "adb shell mount " + real_device + " " + storage_mount_point
	    print cmd_mount
	    execute(cmd_mount)
	response = execute(cmd_list_mount)
    	if re.search (storage_mount_point, response):
	    print "Card Mount Pass\n"
	    cmd_logging = "echo Card Mount Pass >> " + testlog 
	    execute(cmd_logging)
        else:
	    print "Card Mount Failed\n"
	    cmd_logging = "echo Card Mount Failed >> " + testlog 
	    execute(cmd_logging)
	    testVerdict = False
	    
    return testVerdict



#
# [Update 2013-06-26, Henri: Added function storage_unmount()]
# This function will check if device was already mounted first before attempting to unmount device.
# If device was not mounted first, the verdict would be False.
# 

def storage_unmount(device, testVerdict, testlog, OS):
    if (OS == "fedora16"):
    	cmd_list_mount = "df"
    elif (OS == "android"):
	cmd_list_mount = "adb shell df"
    response = execute(cmd_list_mount)

    if re.search ("/media", response): # Check if device is mounted first
        print "Device mounted list:"
	cmd_logging = "Device mounted >> " + testlog 
	execute(cmd_logging)

        testVerdict = common.unmount_all(device, testVerdict, testlog, OS)
    else: # Device was not mounted
        print "Device was not mounted. \n"
	cmd_logging = "Device was not mounted before unmount >> " + testlog 
	execute(cmd_logging)
        testVerdict = False
    return testVerdict


#
# This function will create file for the copy compare stress. dd is used to create that file. Filesize created
# will be based on the device storage capacity and the number of partition for the test case. If number of partition
# is 1, then the file size will be device storage capacity/3. If the number of partition is more than 1, the file size 
# will be device storage capacity/(number of partition + 1)
#

def create_file(file_name, partition, device, testVerdict, smoke_test):

    if(OS == "fedora16"):
    	cmd_device_size = "fdisk -l | grep -w " + device +  " | awk '{print $5}'"
    elif (OS == "android"):
	cmd_device_size = "adb shell fdisk -l " + device + " | grep -w " + device +  " | awk '{print $5}'"

    if (int(partition) == 1):
        partition = 3

    response=execute(cmd_device_size)
    file_size = int(response)
    file_size_to_create = file_size/ (int(partition) + 1)
    if (file_size_to_create > 1000000000):
	print "File size larger than 8GB."
	print "File Format: " + form
	if ((form == "FAT32") | (form == "vFAT")):
		file_size_to_create = 1000000000        # if it is VFAT or FAT32, the largest file size is 4GB, set to 3.5 GB
	else:
		file_size_to_create = 1000000000 	# if file size is larger than 8 GB, cap it at 8GB as that is a valid use case. A single file is rarely more than 8GB
    #elif (file_size_to_create > 4000000000):
	#print "file size larger than 4GB"
	#print "File Format: " + form
	#if ((form == "FAT32") | (form == "vFAT")):
		#file_size_to_create = 3758096384        # if it is VFAT or FAT32, the largest file size is 4GB, set to 3.5 GB
    if (smoke_test == "YES"):
	file_size_to_create = 314572800
    print "file size to create: " + str(file_size_to_create)
    blocksize=int(file_size_to_create)/1024/1024/int(blockcount) #divide by 1024 twice to change to MB. Divide by blockcount to take into account of dd blockcount.
    print "Block size: " + str(blocksize)
    realsizeinMB = blocksize * int(blockcount)  # multiply by blockcount again to reflect real MB. This is for logging purpose.
    #print realsizeinMB
    blocksizeinM=str(blocksize) +"M"     # Concatenate with M for dd command string creation.
#    print response
#    print file_size_to_create
#    print "block size" + str(blocksize)
#    print blocksizeinM
    print "creating " + file_name + " of " + str(realsizeinMB) + "MB"
    cmd_logging = "echo creating " + file_name + " of " + str(realsizeinMB) + "MB >> " + testlog
    execute(cmd_logging)
    if (OS == "fedora16"):
	cmd_generate_file = "dd if=/dev/urandom of=" + file_name + " bs=" + str(blocksizeinM) + " count=" + str(blockcount) # command to generate file
    if (OS == "android"):
	cmd_generate_file = "adb shell dd if=/dev/urandom of=" + file_name + " bs=" + str(blocksizeinM) + " count=" + str(blockcount) # command to generate file
    ret = execute(cmd_generate_file)
#    client_loc = "/media/SATA"
 #   execute("dd if=/dev/urandom of=/root/and.txt bs=" + str(blocksizeinM) + " count=" + str(blockcount))
    if (OS == "fedora16"):
    	cmd_check_file_exist="ls -la " + file_name     #command to check if file is created successfully
    elif (OS == "android"):
    	cmd_check_file_exist="adb shell ls -la " + file_name    #command to check if file is created successfully
    response = execute(cmd_check_file_exist)
    if re.search(file_name, response):
         print file_name + " Created successfully"
  	 cmd_logging = "echo " + file_name + " is created successfully >> \n" + testlog
	 execute(cmd_logging)
    else:    
	 print file_name + " is not created successfully"
	 cmd_logging = "echo " + file_name + " is not created successfully >> \n" + testlog
	 execute(cmd_logging)
	 testVerdict = False
    return testVerdict


#
# This function will create multiple file for the copy compare stress. dd is used to create those files. Filesizes created
# will be based on the device storage capacity and the number of partition for the test case. If number of partition
# is 1, then the sum of file sizes will be device storage capacity/3. If the number of partition is more than 1, the sum of file sizes 
# will be device storage capacity/(number of partition + 1)
#

def create_multiple_file(multiple_directory, partition, device, testVerdict, base_file_name, iteration, blockcount, smoke_test):
#    base_file_name = "file.txt"
    common.create_log_dir(multiple_directory,OS)
#    iteration = 500 #creating 500 files for data transfer
    print "base_file_name: " + base_file_name
    print "iteration: " + str(iteration)

    if(OS == "fedora16"):
    	cmd_device_size = "fdisk -l | grep -w " + device +  " | awk '{print $5}'"
    elif (OS == "android"):
	cmd_device_size = "adb shell fdisk -l " + device + " | grep -w " + device +  " | awk '{print $5}'"
    if (int(partition) == 1):
        partition = 3
    response=execute(cmd_device_size)
    print response
    file_size = int(response)
    file_size_to_create = file_size/ (int(partition) + 1)
    if (file_size_to_create > 8589934592):
	print "file size larger than 8GB"
	if ((form == "FAT32") | (form == "vFAT")):
		file_size_to_create = 3758096384        # if it is VFAT or FAT32, the largest file size is 4GB, set to 3.5 GB
	else:
		file_size_to_create = 8589934592 	# if file size is larger than 8 GB, cap it at 8GB as that is a valid use case. A single file is rarely more than 8GB
    elif (file_size_to_create > 4000000000):
	print "file size larger than 4GB"
	if ((form == "FAT32") | (form == "vFAT")):
		file_size_to_create = 3758096384        # if it is VFAT or FAT32, the largest file size is 4GB, set to 3.5 GB
    if (smoke_test == "YES"):
	file_size_to_create = 314572800
#    print "file size to create: " + str(file_size_to_create)
#    print "blockcount: " + str (blockcount)
    blocksize=float(file_size_to_create)/1024/1024/int(blockcount)/int(iteration) #divide by 1024 twice to change to MB. Divide by blockcount to take into account of dd blockcount. Divide by iteration to take into account the number of files to be created.
    size_param = "M"
#    print "block size" + str(blocksize)
    if (blocksize < 1):               #block size smaller than 1, since it is integer it will be set to 0. Set blocksize to 1 and blockcount to 1.
	blocksize=int(blocksize * 1024)
	size_param = "k"
	

    realsizeinMB = blocksize * int(blockcount)      # multiply by blockcount again to reflect real MB. This is for logging purpose.
#    print realsizeinMB
    blocksizeinM=str(blocksize) +size_param     # Concatenate with M for dd command string creation.
#    print response
#    print file_size_to_create
#    print "block size" + str(blocksize)
#    print blocksizeinM
    for x in range (0, int(iteration)):
        file_name = multiple_directory + "/" + base_file_name + str(x)    # form the file name to be created. file name with incremental numbers.
#    	print "creating " + file_name + " of " + str(realsizeinMB) + " " + size_param + "B"
    	cmd_logging = "echo creating " + file_name + " of " + str(realsizeinMB) +  " " + size_param + "B >> " + testlog
    	execute(cmd_logging)
    	if (OS == "fedora16"):
		cmd_generate_file = "dd if=/dev/urandom of=" + file_name + " bs=" + str(blocksizeinM) + " count=" + str(blockcount)  # command to generate file
    	if (OS == "android"):
		cmd_generate_file = "adb shell dd if=/dev/urandom of=" + file_name + " bs=" + str(blocksizeinM) + " count=" + str(blockcount) # command to generate file
#        print cmd_generate_file
    	ret = execute(cmd_generate_file) 
	if (OS == "fedora16"):
    		cmd_check_file_exist="ls -la " + file_name   #check if file created successfully
    	elif (OS == "android"):
    		cmd_check_file_exist="adb shell ls -la " + file_name  #check if file created successfully
    	response = execute(cmd_check_file_exist)
    	if re.search(file_name, response):
         	print file_name + " Created successfully"
  	 	cmd_logging = "echo " + file_name + " is created successfully >> " + testlog
	 	execute(cmd_logging)
    	else:    
	 	print file_name + " is not created successfully"
	 	cmd_logging = "echo " + file_name + " is not created successfully >> " + testlog
	 	execute(cmd_logging)
		testVerdict = False

    return testVerdict





#
# This function will copy from SATA to the first partition. During the execution, the data transfer rate, memory % utilization
# and CPU % utilization will be collected. After each copy, md5sum will be performed on the original file and the destination file
# to make sure that the copy is successful
#
def copy_compare_stress(file_name, storage_base, testVerdict):
    splitfilename = re.split("/",filename) #split filename so can get filename only
    short_filename = str(splitfilename[len(splitfilename)-1]) # retrive the last index on the array to get filename
    storage_location = storage_base + "1/" + short_filename;   # default copy to 1st storage mount point
    # dut1.execute("cp /root/and.txt " + client_loc)
    if (OS == "fedora16"):
    	cmd_rm = "rm -rf " + storage_base + "1/*" #remove all existing data in the first mount point
    elif (OS == "android"):
	cmd_rm = "adb shell rm -rf " + storage_base + "1/*"  #remove all existing data in the first mount point
    print cmd_rm
    ret = execute(cmd_rm)
    time.sleep(10) # wait for 10 seconds before proceeding with copy. This is because there are times that the cp starts before rm is completed.
    

    if (common.check_file_exist(storage_location, OS) == True):
	print storage_location + " exist. The file is not removed properly ... "
	cmd_logging = "echo " + storage_location + " exist. The file is not removed properly ... >> " + testlog
	execute(cmd_logging)
        execute(cmd_rm)
    else:
	print storage_location + " does not exist. The file has been removed ... "
	cmd_logging = "echo " + storage_location + " does not exist. The file has been removed ... >> " + testlog
	execute(cmd_logging) 
   

    cmd_logging = "echo Copying from " + file_name + " to " + storage_location + " ... >> " + testlog
    execute(cmd_logging) 
    if (OS == "fedora16"):   
	cmd_cp = "cp -f " + file_name + " "+ storage_location
    elif (OS == "android"):   
	cmd_cp = "adb shell cp -f " + file_name + " "+ storage_location
    print cmd_cp
#    g target=common.get_memory_and_cpu_data_transfer, args=('172.30.66.82', 'root', 'abc123', OS, storage_location, performancelog))
#    get_stats.start()
    get_cp_memory_cpu = "top -bc -n 10 | grep -w 'cp' | grep -v 'grep' | awk '{print \"copy,\" $9 \",\" $10}' >> " +  performancelog

    print get_cp_memory_cpu
    execute(get_cp_memory_cpu)
    start = time.time()
    print start
    ret = execute(cmd_cp)
    end = time.time()
    print end
    diff = end - start
    print diff
#    time.sleep(10) # wait for 10 seconds before proceeding with copy. This is because there are times that the cp starts before rm is completed.
    if (OS == "fedora16"):
    	cmd_file_size = "ls -la " + file_name + " | awk '{print $5}'"
    if (OS == "android"):
    	cmd_file_size = "adb shell ls -la " + file_name + " | awk '{print $5}'"
    file_size = execute(cmd_file_size)
    print "file_size " + file_size
    file_size_inM = int(file_size) / 1048576
    transfer_rate = file_size_inM / diff
    print "transfer rate is " + str(transfer_rate) + "MB/s"
    cmd_logging = "echo transfer rate is " + str(transfer_rate) + "MB/s" + " >> " + testlog
    execute(cmd_logging)
    cmd_logging = "echo transfer rate is " + str(transfer_rate) + "MB/s" + " >> " + performancelog
    execute(cmd_logging)
    if (OS == "fedora16"):
    	cmd_checksum_origin = "md5sum " + file_name +" |cut -c -32"
    if (OS == "android"):
    	cmd_checksum_origin = "adb shell md5sum " + file_name +" |cut -c -32"
    originchecksum = execute(cmd_checksum_origin)
    originchecksum = originchecksum.strip("\n\r") # strip newline 
    print "Origin file checksum = " + originchecksum
    cmd_logging = "echo Origin file checksum = " + originchecksum + " >> " + testlog
    execute(cmd_logging)
    if (OS == "fedora16"):
    	cmd_checksum_destination = "md5sum " + storage_location +" |cut -c -32"
    elif (OS == "android"):
    	cmd_checksum_destination = "adb shell md5sum " + storage_location +" |cut -c -32"
    destinationchecksum =  execute(cmd_checksum_destination)
    destinationchecksum = destinationchecksum.rstrip("\n\r") # strip newline 
    print "Destination file checksum = " + destinationchecksum
    cmd_logging = "echo Destination file checksum = " + destinationchecksum + " >> " + testlog
    execute(cmd_logging)
    if (originchecksum==destinationchecksum):
        print "md5sum successful!!"
	cmd_logging = "echo md5sum successful!!"
	execute(cmd_logging)
    else:
        print "md5sum not successful!!"
	cmd_logging = "echo md5sum not successful!!"
	execute(cmd_logging)
	testVerdict = False
   # execute("cp /root/" + file_name + " "+ storage_location)
    return testVerdict

#
# [Update 2013-06-25, Henri] This function will first check if the device is mounted then proceed.
# This function will copy from storage to the first partition, then will process to copy across all the partitions of storage. 
# After each copy, md5sum will be performed on the original file and the destination file
# to make sure that the copy is successful
#

def copy_across_compare(filename, partition, storage_base, testVerdict,performancelog):    
    splitfilename = re.split("/",filename) #split filename so can get filename only
    short_filename = str(splitfilename[len(splitfilename)-1]) # retrive the last index on the array to get filename
# [Updated 2013-06-25, Henri] Added function to check that device is mounted, else copy_across would fail.
    if (OS == "fedora16"):
    	cmd_list_mount = "df"
    elif (OS == "android"):
	cmd_list_mount = "adb shell df"
    response = execute(cmd_list_mount)

    if re.search ("/media", response):
        print "Dev Mount Pass"
	cmd_logging = "Dev Mount Pass >> " + testlog 
	execute(cmd_logging)

        for x in range (0, int(partition)):
	    storage_number = x+1
	    storage_mount_point = storage_base + str(storage_number) + "/" +  short_filename
	    storage_mount_point_original = storage_base + str(x) + "/" + short_filename
	    if (storage_number == 1):
    	       storage_mount_point_original = filename	   
	    if (OS == "fedora16"):
		    cmd_rm = "rm -f " + storage_mount_point
	    elif (OS == "android"):
		    cmd_rm = "adb shell rm -f " + storage_mount_point
	    print "Copying from " + storage_mount_point_original + " to " + storage_mount_point
	    cmd_logging = "echo Copying from " + storage_mount_point_original + " to " + storage_mount_point + " ... >> " + testlog
	    execute(cmd_logging)
	    if (OS == "fedora16"):
		    cmd_copy = "cp -f " + storage_mount_point_original + " " + storage_mount_point
	    elif (OS == "android"):
		    cmd_copy = "abd shell cp -f " + storage_mount_point_original + " " + storage_mount_point
	    print cmd_rm
	    print cmd_copy
	    execute(cmd_rm)
	    time.sleep(10) # wait for 10 seconds before proceeding with copy. This is because there are times that the cp starts before rm is completed.
#        get_stats = multiprocessing.Process(target=common.get_memory_and_cpu_data_transfer, args=('172.30.66.82', 'root', 'abc123', OS, storage_mount_point, performancelog))
#        get_stats.start()
	    execute(cmd_copy)
	    if (OS == "fedora16"):
		    cmd_checksum_origin = "md5sum " + storage_mount_point_original +" |cut -c -32"
	    elif (OS == "android"):
		    cmd_checksum_origin = "adb shell md5sum " + storage_mount_point_original +" |cut -c -32"
	    originchecksum = execute(cmd_checksum_origin)
	    originchecksum = originchecksum.strip("\n\r") # strip newline 
	    print "Origin file checksum = " + originchecksum
	    cmd_logging = "echo Origin file checksum = " + originchecksum + " >> " + testlog
	    print cmd_logging
	    execute(cmd_logging)
	    if (OS == "fedora16"):
		    cmd_checksum_destination = "md5sum " + storage_mount_point +" |cut -c -32"
	    elif (OS == "android"):
		    cmd_checksum_destination = "adb shell md5sum " + storage_mount_point +" |cut -c -32"
	    destinationchecksum =  execute(cmd_checksum_destination)
	    destinationchecksum = destinationchecksum.rstrip("\n\r") # strip newline 
	    print "Destination file checksum = " + destinationchecksum
	    cmd_logging = "echo Destination file checksum = " + destinationchecksum + " >> " + testlog
            print cmd_logging
	    execute(cmd_logging)
	    if (originchecksum == destinationchecksum ):
	       print "Check sum successful for " + storage_mount_point_original + " and " + storage_mount_point
	       cmd_logging = "echo Check sum successful for " + storage_mount_point_original + " and " + storage_mount_point + " >> " + testlog
	       execute(cmd_logging)
	    else:
	       print "Check sum not successful for " + storage_mount_point_original + " and " + storage_mount_point
	       cmd_logging = "echo Check sum not successful for " + storage_mount_point_original + " and " + storage_mount_point + " >> " + testlog
	       execute(cmd_logging)
	       testVerdict = False
	    common.get_memory_and_cpu("summary", performancelog, OS)
        # End of if
    else:
        print "Dev Mount Failed"
	cmd_logging = "Dev Mount Failed >> " + testlog 
	execute(cmd_logging)
        testVerdict = False
    return testVerdict

#
# This function will copy from storage to the first partition. During the execution, the data transfer rate, memory % utilization
# and CPU % utilization will be collected. After each copy, md5sum will be performed on the original file and the destination file
# to make sure that the copy is successful
#
def copy_compare_multiple_stress(multiple_directory, storage_base, testVerdict,base_file_name, iteration):
#    base_file_name = "file.txt"
#    iteration = 500
    total_size=0
    storage_location = storage_base + "1/";   # default copy to 1st storage mount point
    # dut1.execute("cp /root/and.txt " + client_loc)
    if (OS == "fedora16"):
    	cmd_rm = "rm -rf " + storage_base + "1/*" #remove all existing data in the first mount point
    elif (OS == "android"):
	cmd_rm = "adb shell rm -rf " + storage_base + "1/*"  #remove all existing data in the first mount point
    print cmd_rm
    ret = execute(cmd_rm)
    time.sleep(10) # wait for 10 seconds before proceeding with copy. This is because there are times that the cp starts before rm is completed.
    

    if (common.check_folder_empty(storage_location, OS) == True):
	print storage_location + " is empty. Files are removed properly ... "
	cmd_logging = "echo " + storage_location + " is empty. Files are removed properly ... >> " + testlog
	execute(cmd_logging)
        execute(cmd_rm)
    else:
	print storage_location + " is not empty. Files still exist ... "
	cmd_logging = "echo " + storage_location + " is not empty. Files still exist ... >> " + testlog
	execute(cmd_logging) 
        testverdict = False
   
#    cmd_clearcache = "sync; echo 3 > /proc/sys/vm/drop_caches"
#    execute(cmd_clearcache)
    cmd_logging = "echo Copying from " + multiple_directory + " to " + storage_location + " ... >> " + testlog
    execute(cmd_logging) 
    if (OS == "fedora16"):   
	cmd_cp = "cp -rf " + multiple_directory + "/* "+ storage_location
    elif (OS == "android"):   
	cmd_cp = "adb shell cp -rf " + multiple_directory + "/* "+ storage_location
    print cmd_cp
#    g target=common.get_memory_and_cpu_data_transfer, args=('172.30.66.82', 'root', 'abc123', OS, storage_location, performancelog))
#    get_stats.start()
    get_cp_memory_cpu = "top -bc -n 10 | grep -w 'cp' | grep -v 'grep' | awk '{print \"copy multi,\" $9 \",\" $10}' >> " +  performancelog
    print get_cp_memory_cpu
    execute(get_cp_memory_cpu)
#    start = time.clock()
    start = time.time()
    print start
    ret = execute(cmd_cp)
#    end = time.clock()
    end = time.time()
    print end
    diff = end - start
    print diff
    for x in range (0, int(iteration)):
	file_name = multiple_directory + "/" + base_file_name + str(x)
    	if (OS == "fedora16"):
    		cmd_file_size = "ls -la " + file_name + " | awk '{print $5}'"
    	if (OS == "android"):
    		cmd_file_size = "adb shell ls -la " + file_name + " | awk '{print $5}'"
    	file_size = execute(cmd_file_size)
        total_size = total_size + int(file_size)

    print "total_size " + str(total_size)
    total_size_inM = int(total_size) / 1048576
    transfer_rate = total_size_inM / diff
    print "transfer rate is " + str(transfer_rate) + "MB/s"
    cmd_logging = "echo transfer rate is " + str(transfer_rate) + "MB/s" + " >> " + testlog
    execute(cmd_logging)
    cmd_logging = "echo transfer rate is " + str(transfer_rate) + "MB/s" + " >> " + performancelog
    execute(cmd_logging)

    for x in range (0, int(iteration)):
	file_name = multiple_directory + "/" + base_file_name + str(x)
    	if (OS == "fedora16"):
    		cmd_checksum_origin = "md5sum " + file_name +" |cut -c -32"
	if (OS == "android"):
    		cmd_checksum_origin = "adb shell md5sum " + file_name +" |cut -c -32"
    	originchecksum = execute(cmd_checksum_origin)
    	originchecksum = originchecksum.strip("\n\r") # strip newline 
    	print "Origin file checksum = " + originchecksum
    	cmd_logging = "echo Origin file checksum = " + originchecksum + " >> " + testlog
    	execute(cmd_logging)
        file_name_destination = storage_location + "/" + base_file_name + str(x)
    	if (OS == "fedora16"):
    		cmd_checksum_destination = "md5sum " + file_name_destination +" |cut -c -32"
    	elif (OS == "android"):
    		cmd_checksum_destination = "adb shell md5sum " + file_name_destination +" |cut -c -32"
    	destinationchecksum =  execute(cmd_checksum_destination)
    	destinationchecksum = destinationchecksum.rstrip("\n\r") # strip newline 
    	print "Destination file checksum = " + destinationchecksum
    	cmd_logging = "echo Destination file checksum = " + destinationchecksum + " >> " + testlog
    	execute(cmd_logging)
    	if (originchecksum==destinationchecksum):
        	print "md5sum successful!!"
		cmd_logging = "echo md5sum successful!!"
		execute(cmd_logging)
    	else:
        	print "md5sum not successful!!"
		cmd_logging = "echo md5sum not successful!!"
		execute(cmd_logging)
		testVerdict = False
    return testVerdict
    
def my_multiprocess(file_name, storage_location):
    getmemcpu = multiprocessing.Process(target=get_memory_and_cpu)
    copycom = multiprocessing.Process(target=copy_compare, args=(file_name, storage_location))
    
    copycom.start()
    getmemcpu.start()

def my_fork(file_name, storage_location):    
    child_pid = os.fork()
    if child_pid == 0:
        copy_compare(file_name, storage_location)
    else:
        sleep(5)
        get_memory_cpu()

#
# This function will partition the storage drive to the number of partitions passed into the function. This function will call a shell script that resides in the DUT to complete this operation.
# The shell script is partitions.sh. In fedora16, partitions.sh should be stored in the /root folder. In Android, partitions.sh should be stored in the /data folder.
#

def part (partition, device, testVerdict):
    if (OS == "fedora16"):
    	cmd_check_device_capacity = "fdisk -l " + device + " | grep -w " + device +  " | awk '{print $5}'"
    elif (OS == "android"):
    	cmd_check_device_capacity = "adb shell fdisk -l " + device + " | grep -w " + device +  " | awk '{print $5}'"
    response = execute(cmd_check_device_capacity)
    print "Disk capacity: " + response 
    cmd_logging = "echo disk capacity = " + response + " >> " + testlog 
    execute(cmd_logging)
    each_partition_capacity = int(response) / int(partition)
#    print "each partition capacity " + each_partition_capacity	
    each_partition_capacity_in_MB = each_partition_capacity/1048576
    each_partition_capacity_in_MB = each_partition_capacity_in_MB - 20
    print "Each partition capacity: " + str(each_partition_capacity_in_MB)
    cmd_logging = "echo each partition capacity " + str(each_partition_capacity_in_MB) + " >> " + testlog
    execute(cmd_logging)
    if (int(partition) == 2):
	if(OS == "fedora16"):
		cmd_partition_script = "/root/partitions.sh " +  device + " " + str(partition) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB)
	elif (OS == "android"):
		cmd_partition_script = "adb shell /data/partitions.sh " +  device + " " + str(partition) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB)
    elif (int(partition) == 5):
        if(OS == "fedora16"):
        	cmd_partition_script = "/root/partitions.sh " +  device + " " + str(partition) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB)
	if(OS == "android"):
        	cmd_partition_script = "adb shell /data/partitions.sh " +  device + " " + str(partition) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB) + " " + str(each_partition_capacity_in_MB)
    elif (int(partition) == 1):
	if(OS == "fedora16"):
	        cmd_partition_script = "/root/partitions.sh " +  device + " " + str(partition)
	if(OS == "android"):
	        cmd_partition_script = "adb shell /data/partitions.sh " +  device + " " + str(partition)
    else:
        print "Only 1, 2 and 5 partitions are supported"
	cmd_logging = "echo Only 1, 2 and 5 partitions are supported >> " + testlog
	execute(cmd_logging)

#    print cmd_partition_script
    response = execute(cmd_partition_script)
#    print "reponse " + response

    time.sleep(10)
    for x in range (0, int(partition)):
        if (x <=2):             # primary partition only
            device_number = x + 1
        else:                   # skip extended partition 
            device_number = x + 2
        if (storage == "SD"):
            real_device = device + "p" + str(device_number)
        else:
            real_device = device + str(device_number)
            
	if (OS == "fedora16"):
	        cmd_check_partition = "fdisk -l " + real_device + " | grep -w " + real_device # grep device with exact match only
	elif (OS == "android"):
		cmd_check_partition = "adb shell fdisk -l " + real_device + " | grep -w " + real_device # grep device with exact match only
	print cmd_check_partition
        response = execute(cmd_check_partition)
	print response
        if (re.search(real_device,response) ):
            print "partition " + real_device + " found"
	    cmd_logging = "echo partition " + real_device + " found" + " >> " + testlog
	    execute(cmd_logging)
        else:
            print "partition " + real_device + " not found"
	    cmd_logging = "echo partition " + real_device + " not found" + " >> " + testlog
	    execute(cmd_logging)
	    testVerdict = False
    return testVerdict
    
def formatting(partition, formatting, disk, testVerdict):
    if (formatting == "ext"):
	if (OS == "fedora16"):
        	cmd_format_command="mkfs.ext "
	elif (OS == "android"):
		cmd_format_command="adb shell mkfs.ext "
        print "ext"
    elif (formatting == "ext2"):
	if (OS == "fedora16"):
	        cmd_format_command="mkfs.ext2 " #available in android
	elif (OS == "android"):
		cmd_format_command="adb shell mkfs.ext2 " #available in android
        print "ext2"
    elif (formatting == "ext3"):
	if (OS == "fedora16"):
	        cmd_format_command="mkfs.ext3 "
	if (OS == "android"):
		cmd_format_command="adb shell mkfs.ext3 "
        print "ext3"
    elif (formatting == "ext4"):
	if (OS == "fedora16"):
        	cmd_format_command="mkfs.ext4 "
	elif (OS == "android"):
		cmd_format_command="adb shell mkfs.ext4 "
        print "ext4"
    elif (formatting == "FAT32"):	#available in android
	if (OS == "fedora16"):
	        cmd_format_command="mkdosfs -F 32 "
	if (OS == "android"):
	        cmd_format_command="adb shell mkdosfs -F 32 "
        print "FAT32"
    elif (formatting == "vFAT"):	#available in android
	if ( OS == "fedora16"):
	        cmd_format_command="mkfs.vfat "
	if ( OS == "android"):
	        cmd_format_command="adb shell mkfs.vfat "

        print "vFAT"
    else:
        print "incorrect format"

    if (storage == "SD"):
        disk1 = disk + "p1"
    else:
        disk1 = disk + "1"

    format_disk1 = cmd_format_command + disk1
    print format_disk1
    if (storage == "SD"):
        disk2 = disk + "p2"
    else:
        disk2 = disk + "2"

    format_disk2 = cmd_format_command + disk2
    print format_disk2
    if (storage == "SD"):
        disk3 = disk + "p3"
    else:
        disk3 = disk + "3"

    format_disk3 = cmd_format_command + disk3
    print format_disk3
    if (storage == "SD"):
        disk4 = disk + "p5"
    else:
        disk4 = disk + "5"

    format_disk4 = cmd_format_command + disk4
    print format_disk4
    if (storage == "SD"):
        disk5 = disk + "p6"
    else:
        disk5 = disk + "6"

    format_disk5 = cmd_format_command + disk5
    print format_disk5
       
    if (int(partition) == 2):
        execute(format_disk1)
        execute(format_disk2)
    elif (int(partition) == 5):
        execute(format_disk1)
        execute(format_disk2)
        execute(format_disk3)
        execute(format_disk4)
        execute(format_disk5)
    elif (int(partition) == 1):
        execute(format_disk1)
    else:
        print "incorrect partition option"

    #time.sleep(300)
    for x in range (0, int(partition)):
        if (x <=2):             # primary partition only
            device_number = x + 1
        else:                   # skip extended partition 
            device_number = x + 2
        if (storage == "SD"):
            real_device = device + "p" + str(device_number)
        else:
            real_device = device + str(device_number)
        
	if (OS == "fedora16"):
	        cmd_check_format = "file -sL " + real_device
	elif (OS == "android"):
		cmd_check_format = "adb shell file -sL " + real_device
	print cmd_check_format
        response = execute(cmd_check_format)
        print "response: " + response

        ## form format checking keyword for formatting verification
        if (formatting == "ext"):
            format_keyword="ext "
        elif (formatting == "ext2"):
            format_keyword="ext2 "
        elif (formatting == "ext3"):
            format_keyword="ext3 "
        elif (formatting == "ext4"):
            format_keyword="ext4 "
        elif (formatting == "FAT32"):
            format_keyword="FAT "
        elif (formatting == "vFAT"):
            format_keyword="FAT "
        else:
            print "incorrect format"
        if (re.search(format_keyword,response) ):
            print real_device + " with " + format_keyword + " format found: Created successfully"
	    cmd_logging = "echo " + real_device + " with " + format_keyword + " format found:Created successfully" + " >> " + testlog
	    execute(cmd_logging)
        else:
            print real_device + " with " + format_keyword + " format not found: Not created"
	    cmd_logging = "echo " + real_device + " with " + format_keyword + " format not found: Not created" + " >> " + testlog
	    execute(cmd_logging)
	    testVerdict = False
         
    return testVerdict
 #   execute("cp /root/" + file_name + " "+ storage_location + "/" + file_name +"1")
 #   destinationchecksum =  execute("md5sum " + storage_location + "/" + file_name + "1 |cut -c -32")
 #   print destinationchecksum
 #   if (originchecksum==destinationchecksum):
 #       print "md5sum successful!!"

 #   execute("cp /root/" + file_name + " "+ storage_location + "/" + file_name +"2")
 #   destinationchecksum =  execute("md5sum " + storage_location + "/" + file_name + "2 |cut -c -32")
 #   print destinationchecksum
 #   if (originchecksum==destinationchecksum):
 #       print "md5sum successful!!"
        


if __name__ == '__main__':    
    #Meego_Host_IP = "10.221.119.140"
#    Meego_Host_IP = "10.221.119.47"
    blockcount = "10"
    testVerdict = True
    base_file_name = "file.txt"
    file_iteration = 500


    currentDate = common.get_date()  # get today's date
    Time_now = common.get_current_time() # get current time
    date_time = currentDate + "_" + Time_now  #form timestamp


### Get Argument ###
### common argument, testID, OS, projectID
    try:
    	opts, args = getopt.getopt(sys.argv[1:], 'o:i:t:p:f:d:b:s:e:h:q:')
    	for opt, arg in opts:
       	    if opt == '-i':
            	iteration = str(arg)
	    elif opt == '-t':
            	testID = str(arg)
            elif opt == '-p':
            	partition = str(arg)
            elif opt == '-f':
            	form = str(arg)
            elif opt == '-d':
            	device = str(arg)
            elif opt == '-o':
            	operation = str(arg)    
            elif opt == '-b':
            	storage_base = str(arg)
	    elif opt == '-s':
            	OS = str(arg)
            elif opt == '-e':
            	storage = str(arg)
            #elif opt == '-h':
               #port = str(arg)
	    #elif opt == '-q':
            	#ip = str(arg)
    except StandardError , e:
        print e

    if (storage == "SATA"):	
    	storage_LOG_location = "/root/SATA_LOG"
    	storage_LOG_DATE_location = "/root/SATA_LOG/" + currentDate
    elif (storage == "USB"):	
    	storage_LOG_location = "/root/USB_LOG"
    	storage_LOG_DATE_location = "/root/USB_LOG/" + currentDate
    elif (storage == "SD"):	
    	storage_LOG_location = "/root/SD_LOG"
    	storage_LOG_DATE_location = "/root/SD_LOG/" + currentDate
    else:	
    	print "Invalid storage type"
        sys.exit(1)

#    ip = "10.221.110.72"
    #Meego_Host_IP = ip	
    #dut = GenericCommand.GenericCommand()
    #dut.login(Meego_Host_IP, port)
	

    #common.create_log_dir(storage_LOG_location, dut, OS)
    #common.create_log_dir(storage_LOG_DATE_location, dut, OS)

    testlog = storage_LOG_location + "/" + currentDate + "/" + testID + "_"+ operation + "_" + date_time + ".log"    	
    performancelog = storage_LOG_location + "/" + currentDate + "/" + testID + "_"+ operation + "_performance.csv"   

#cmd_preset_time = date_time
#execute(cmd_preset_time)
#print "cmd_preset_time: " + cmd_preset_time
    cmd_preset = "echo ================== " + date_time + " =========================== >> " + performancelog
    execute(cmd_preset)
    cmd_preset = "\n\n" + "echo OPERATION,CPU%,MEM% >> " + performancelog
    #print cmd_preset
    execute(cmd_preset)

#if __name__ == '__main__':   
#   dut = GenericCommand.GenericCommand()
#   dut.login(Meego_Host_IP)

    if (OS == "fedora16"):
	filename="/root/and.txt"   #filename to be created for data transfer
        multiple_directory = "/root/multi"  #directory to store multiple files for data transfer
    elif (OS == "android"):
	filename="/mnt/sdcard/and.txt"     #filename to be created for data transfer
        multiple_directory = "/mnt/sdcard/multi"    #directory to store multiple files for data transfer
    print "\n" + "-Parameter Input-" + "\n" + "Iteration: " + str(iteration)
    print "TestID: " + str(testID)
    print "Partition: " + partition
    print "Device: " + device + "\n" + "Operation: " + operation + "\n\n" + "-START " + operation + "-"
	
    if (operation == "partition"):
    	testVerdict = part(partition, device, testVerdict)
    elif (operation == "unmount"):
	testVerdict = storage_unmount(device, testVerdict, testlog, OS)
# [Update 2013-06-26, Henri: Comment out the line below, added the line above]
#    	testVerdict = common.unmount_all(device, testVerdict, testlog, OS)
    elif (operation == "format"):
    	testVerdict = formatting(partition, form, device, testVerdict)
    elif (operation == "mount"):
    	testVerdict = storage_mount(partition, device, storage_base, testVerdict)
    elif (operation == "create_file"):
    	testVerdict = create_file(filename, partition, device, testVerdict, "NO")
    elif (operation == "create_file_smoke"):
    	testVerdict = create_file(filename, partition, device, testVerdict, "YES")
    elif (operation == "create_multiple_file"):
    	testVerdict = create_multiple_file(multiple_directory, partition, device, testVerdict,base_file_name, file_iteration,blockcount, "NO")
    elif (operation == "create_multiple_file_smoke"):
    	testVerdict = create_multiple_file(multiple_directory, partition, device, testVerdict,base_file_name, file_iteration,blockcount, "YES")
    elif (operation == "copy_across"):
    	testVerdict = copy_across_compare(filename, partition, storage_base, testVerdict,performancelog)
    elif (operation == "copy_compare_stress"):
    	common.get_memory_and_cpu("summary", performancelog, OS)
    	for x in range (0, int(iteration)):
    	    testVerdict = copy_compare_stress(filename, storage_base, testVerdict)
    	    common.get_memory_and_cpu("summary",performancelog, OS)
	    cmd_logging = "echo =========================================================== >> " + performancelog
	    execute(cmd_logging)
    elif (operation == "copy_compare_multiple_stress"):
    	common.get_memory_and_cpu("summary", performancelog, OS)
    	for x in range (0, int(iteration)):
    	    testVerdict = copy_compare_multiple_stress(multiple_directory, storage_base, testVerdict,base_file_name, file_iteration)
    	    common.get_memory_and_cpu("summary",performancelog, OS)
            cmd_logging = "echo =========================================================== >> " + performancelog
	    execute(cmd_logging)
    else:
    	testVerdict = False

    #print testVerdict

    if testVerdict == True:
        print "Result: "	
    	print "Test verdict is TRUE! \n" + "-END " + operation + "- \n"
    	sys.exit(0)
    else:
        print "Result: "
    	print "Test verdict is FALSE! \n" + "-END " + operation + "- \n"
    	sys.exit(1)



# my_multiprocess(filename, storage_loc)
#    getmemcpu = multiprocessing.Process(target=get_memory_and_cpu)
#    copycom = multiprocessing.Process(target=copy_compare, args=(filename, storage_loc))
    
#    getmemcpu.start()
#    copycom.start()

    
